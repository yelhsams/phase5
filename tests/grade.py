#!/usr/bin/env python3

import subprocess
import tempfile
import os
from pathlib import Path

def run_command(cmd: list[str], timeout: int = 30):
    """Run a command and return the result."""
    try:
        return subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        print(f"Command timed out after {timeout} seconds")
        return None
    except Exception as e:
        print(f"Command failed: {e}")
        return None

def run_lexer_test(test_file: Path) -> tuple[bool, str]:
    """Run a single lexer test and return (passed, message)."""
    expected_lex_file = test_file.with_suffix('.mit.lex')

    with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_file:
        command = ["./run.sh", "scan", str(test_file), "-o", temp_file.name]
        temp_file_path = temp_file.name
        result = run_command(command)

    if result is None:
        return False, "Test execution failed"

    try:
        if expected_lex_file.exists():
            try:
                with open(expected_lex_file, 'r') as expected, open(temp_file_path, 'r') as actual:
                    expected_content = expected.read()
                    actual_content = actual.read()

                passed = (expected_content.strip() == actual_content.strip())
                message = "Passed" if passed else "Failed - output doesn't match expected"

            finally:
                os.unlink(temp_file_path)

        else:
            passed = result.returncode != 0
            message = "Passed" if passed else f"Failed - expected error but got exit code {result.returncode}"

        return passed, message

    except Exception as e:
        return False, f"Test execution failed: {str(e)}"

def run_parser_test(test_file: Path) -> tuple[bool, str]:
    """Run a single parser test and return (passed, message)."""
    test_name = test_file.name

    command = ["./run.sh", "parse", str(test_file)]
    result = run_command(command)

    if result is None:
        return False, "Test execution failed"

    if "good" in test_name:
        passed = result.returncode == 0
        expected_behavior = "success"
    elif "bad" in test_name:
        passed = result.returncode != 0
        expected_behavior = "error"
    else:
        passed = False
        expected_behavior = "unknown"

    if passed:
        message = "Passed"
    else:
        message = f"Failed - expected {expected_behavior} but got exit code {result.returncode}"

    return passed, message

def run_compiler_test(test_file: Path) -> tuple[bool, str]:
    """Run a single compiler test and return (passed, message)."""
    expected_mitbc_file = test_file.with_suffix('.mitbc')

    # Skip test if no expected output file exists
    if not expected_mitbc_file.exists():
        return True, "Skipped - no expected output"

    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.mitbc') as temp_file:
        command = ["./run.sh", "compile", str(test_file), "-o", temp_file.name]
        temp_file_path = temp_file.name
        result = run_command(command)

    if result is None:
        try:
            os.unlink(temp_file_path)
        except:
            pass
        return False, "Test execution failed"

    try:
        # Check if compilation succeeded
        if result.returncode != 0:
            try:
                os.unlink(temp_file_path)
            except:
                pass
            return False, f"Compilation failed with exit code {result.returncode}\nStderr: {result.stderr[:200]}"

        # Run expected bytecode through VM and capture output
        expected_vm_command = ["./run.sh", "vm", str(expected_mitbc_file)]
        expected_vm_result = run_command(expected_vm_command, timeout=10)

        if expected_vm_result is None:
            try:
                os.unlink(temp_file_path)
            except:
                pass
            return False, "Failed to run expected bytecode through VM"

        if expected_vm_result.returncode != 0:
            try:
                os.unlink(temp_file_path)
            except:
                pass
            return False, f"Expected bytecode VM execution failed with exit code {expected_vm_result.returncode}\nStderr: {expected_vm_result.stderr[:200]}"

        # Run generated bytecode through VM and capture output
        actual_vm_command = ["./run.sh", "vm", temp_file_path]
        actual_vm_result = run_command(actual_vm_command, timeout=10)

        if actual_vm_result is None:
            try:
                os.unlink(temp_file_path)
            except:
                pass
            return False, "Failed to run generated bytecode through VM"

        if actual_vm_result.returncode != 0:
            try:
                os.unlink(temp_file_path)
            except:
                pass
            return False, f"Generated bytecode VM execution failed with exit code {actual_vm_result.returncode}\nStderr: {actual_vm_result.stderr[:200]}"

        # Compare VM outputs
        try:
            expected_output = expected_vm_result.stdout
            actual_output = actual_vm_result.stdout

            # Normalize line endings and trailing whitespace
            expected_lines = expected_output.strip().split('\n')
            actual_lines = actual_output.strip().split('\n')

            # Compare line by line
            passed = (expected_lines == actual_lines)

            if passed:
                message = "Passed"
            else:
                message = "Failed - VM output doesn't match expected"
                # Show first difference for debugging
                for i, (exp, act) in enumerate(zip(expected_lines, actual_lines)):
                    if exp != act:
                        message += f"\n    Line {i+1}: expected '{exp}' but got '{act}'"
                        break
                if len(expected_lines) != len(actual_lines):
                    message += f"\n    Expected {len(expected_lines)} lines but got {len(actual_lines)}"

        finally:
            os.unlink(temp_file_path)

        return passed, message

    except Exception as e:
        try:
            os.unlink(temp_file_path)
        except:
            pass
        return False, f"Test execution failed: {str(e)}"

def run_vm_test(test_file: Path) -> tuple[bool, str]:
    """Run a single VM test and return (passed, message)."""
    expected_out_file = test_file.with_suffix('.out')

    # Skip test if no expected output file exists
    if not expected_out_file.exists():
        return True, "Skipped - no expected output"

    # Check if we should run from .mitbc or .mit
    mitbc_file = test_file.with_suffix('.mitbc')
    if mitbc_file.exists():
        # Run from compiled bytecode
        command = ["./run.sh", "vm", str(mitbc_file)]
    else:
        # Try running directly - might not be supported
        command = ["./run.sh", "run", str(test_file)]

    result = run_command(command, timeout=10)

    if result is None:
        return False, "Test execution failed or timed out"

    try:
        # Check for runtime errors
        if result.returncode != 0:
            return False, f"VM exited with error code {result.returncode}\nStderr: {result.stderr[:200]}"

        # Read expected output
        with open(expected_out_file, 'r') as expected:
            expected_content = expected.read()

        # Get actual output from stdout
        actual_content = result.stdout

        # Normalize line endings and trailing whitespace
        expected_lines = expected_content.strip().split('\n')
        actual_lines = actual_content.strip().split('\n')

        # Compare line by line
        passed = (expected_lines == actual_lines)

        if passed:
            message = "Passed"
        else:
            message = "Failed - output doesn't match expected"
            # Show first difference for debugging
            for i, (exp, act) in enumerate(zip(expected_lines, actual_lines)):
                if exp != act:
                    message += f"\n    Line {i+1}: expected '{exp}' but got '{act}'"
                    break
            if len(expected_lines) != len(actual_lines):
                message += f"\n    Expected {len(expected_lines)} lines but got {len(actual_lines)}"

        return passed, message

    except Exception as e:
        return False, f"Test execution failed: {str(e)}"

def main():
    """Run all tests."""
    import argparse

    parser = argparse.ArgumentParser(description='Run MITScript tests')
    parser.add_argument('--phase', type=int, choices=[1, 2, 3, 4], help='Test phase (1=lexer/parser, 2=interpreter, 4=compiler/vm)')
    parser.add_argument('--test-dir', type=str, help='Test directory (default: auto-detect based on phase)')
    parser.add_argument('--test', type=str, help='Run specific test file')
    args = parser.parse_args()

    # If specific test is specified
    if args.test:
        test_file = Path(args.test)
        if not test_file.exists():
            print(f"Test file {test_file} not found")
            return

        print(f"Running single test: {test_file.name}")
        print()

        # Run all applicable tests
        if not args.phase or args.phase == 1:
            lexer_passed, lexer_msg = run_lexer_test(test_file)
            print(f"  Lexer: {lexer_msg}")

            parser_passed, parser_msg = run_parser_test(test_file)
            print(f"  Parser: {parser_msg}")

        if not args.phase or args.phase in [2, 3, 4]:
            if not args.phase or args.phase == 4:
                compiler_passed, compiler_msg = run_compiler_test(test_file)
                print(f"  Compiler: {compiler_msg}")

            vm_passed, vm_msg = run_vm_test(test_file)
            print(f"  VM: {vm_msg}")

        return

    # Determine test directory
    if args.test_dir:
        test_dir = Path(args.test_dir)
    elif args.phase:
        test_dir = Path(f"tests/phase{args.phase}")
    else:
        # Try to auto-detect
        for phase in [4, 3, 2, 1]:
            test_dir = Path(f"tests/phase{phase}")
            if test_dir.exists():
                args.phase = phase
                break
        else:
            print("No test directory found. Please specify --test-dir or --phase")
            return

    if not test_dir.exists():
        print(f"Test directory {test_dir} not found")
        return

    # Collect tests
    public_tests = list((test_dir / "public").glob("*.mit"))
    if not public_tests:
        public_tests = list(test_dir.glob("*.mit"))

    private_dir = test_dir / "private"
    private_tests = list(private_dir.glob("*.mit")) if private_dir.exists() else []

    all_tests = sorted(public_tests + private_tests)

    if not all_tests:
        print("No test files found")
        return

    print(f"Running tests from {test_dir}")
    print(f"Found {len(all_tests)} tests ({len(public_tests)} public, {len(private_tests)} private)")
    print()

    passed_tests = 0
    total_tests = 0

    # Determine which tests to run based on phase
    run_lexer = args.phase in [1, None]
    run_parser = args.phase in [1, None]
    run_compiler = args.phase in [4, None]
    run_vm = args.phase in [4, None]

    for test_file in all_tests:
        print(f"Testing {test_file.name}:")
        test_count = 0
        test_passed = 0

        # Run lexer test
        if run_lexer:
            lexer_passed, lexer_msg = run_lexer_test(test_file)
            print(f"  Lexer: {lexer_msg}")
            if lexer_passed:
                test_passed += 1
            test_count += 1

        # Run parser test
        if run_parser:
            parser_passed, parser_msg = run_parser_test(test_file)
            print(f"  Parser: {parser_msg}")
            if parser_passed:
                test_passed += 1
            test_count += 1

        # Run compiler test
        if run_compiler:
            compiler_passed, compiler_msg = run_compiler_test(test_file)
            print(f"  Compiler: {compiler_msg}")
            if compiler_passed:
                test_passed += 1
            test_count += 1

        # Run VM test
        if run_vm:
            vm_passed, vm_msg = run_vm_test(test_file)
            print(f"  VM: {vm_msg}")
            if vm_passed:
                test_passed += 1
            test_count += 1

        passed_tests += test_passed
        total_tests += test_count
        print()

    print(f"Results: {passed_tests}/{total_tests} tests passed")
    print(f"Pass rate: {100.0 * passed_tests / total_tests:.1f}%")

    if passed_tests == total_tests:
        print("✓ All tests passed!")
        return 0
    else:
        failed = total_tests - passed_tests
        print(f"✗ {failed} test(s) failed.")
        return 1

if __name__ == "__main__":
    exit(main() or 0)
